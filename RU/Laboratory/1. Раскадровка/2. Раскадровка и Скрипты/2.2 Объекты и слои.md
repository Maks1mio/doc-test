![image](https://github.com/Maks1mio/doc-test/assets/44835662/1811b10e-1e20-4f61-b2c7-82f1d7d13267)

# Объекты и слои
## Объекты и слои

Помните, что раскадровка в своей простейшей форме - это фоновая анимация, которая служит фоном для битмапа. Возможно, вы замечали раскадровки с текстами песен, врывающимися, словно в караоке, частицами фуэго, создающими фейерверк веселья, или даже спектральными полосами, пульсирующими в такт музыке, словно это визуализация медиаплеера. Все эти изображения, будь то текст песни или маленькая сверкающая точка, являются графическими объектами. При раскадровке мы помещаем графические объекты, часто называемые спрайтами, на фон битмапа, а затем указываем этим спрайтам, что делать. В этой главе мы покажем вам первую половину этого процесса - создание этих графических объектов.

### Протест!

Объект - это, по сути, графика, которую мы хотим отобразить на раскадровке. Существует два вида графики, из которой может быть создан объект: один файл изображения, называемый спрайтом, или серия файлов изображений, называемая анимацией. Хотя анимация имеет свое применение (например, персонаж бежит от одной стороны экрана к другой), раскадровщики в подавляющем большинстве случаев создают спрайты, поскольку для создания волшебства им достаточно одного единственного изображения.

<note>
<div class="svg-icon"><img src="lib/svg/laboratory/note.svg" alt=""></div><code
class="language-text">В наше время, когда создание игр становится все более доступным, термин спрайт стал гораздо более распространенным. Считайте, что раскадровка спрайта - это то же самое, о чем вы могли слышать в дизайне игр. На самом деле, вы случайно не знаете происхождение слова спрайт? Это не из-за безалкогольного напитка, знаете ли! Еще в начале 1980-х годов для повышения эффективности рисования спрайты при рендеринге располагались на отдельном уровне от фона. Их "плавающее" перекрытие очень напоминало мифического спрайта или призрака. Вот так!</code>
</note>


## Давайте создадим объект!
Давайте начнем с создания спрайта! Чтобы создать новый спрайт, в файле .osb напишите следующую строку: ... code-block:: c

<div class="code-container">
    <div class="svg-icon"><img src="~/staticV2/svg/laboratory/browser-code.svg" alt=""></div>
    <pre class="language-csharp"><code id="text-to-copy-1" class="language-csharp">Sprite, <<span>layer>, <</span>origin>, "<<span>filepath>", <<span>x>, <<span>y></code></pre>
    <button class="copy-button" data-input-id="text-to-copy-1" type="button"><img
            src="~/staticV2/svg/laboratory/content-copy.svg" alt=""></button>
</div>
        
Где...
- `<layer>`: [Cлой](/laboratory.html#theme-0-sub-list-1-0.1), на котором будет отображаться спрайт.
- `<origin>`: Место на изображении, на котором будет основана позиция (x,y).
- `<filepath>`: Имя файла нужного вам изображения.
- `<x>, <y>`: Координаты (x,y) места, где должен появиться спрайт.

Давайте разложим все по полочкам. Если вы уже имеете представление об этих вещах, вы можете [перейти к тому, где мы собираем все вместе](https://osb.moe/learn/docs/storyboarding/scripting/objects_and_layers/#applying). После каждого раздела мы будем постепенно заменять каждый из этих пунктов примером, в итоге мы получим настоящий, законный спрайт, который можно использовать и играть с ним!

### Слои: Складывайте их

В традиционной анимации аниматорам приходится рисовать каждый кадр вручную. Однако нарисовать каждый кадр Astro Boy в пустоте гораздо проще, чем нарисовать его в просторах шумного города. Представьте себе, сколько работы нужно проделать, чтобы перерисовать и Астро Боя, и городской пейзаж! И тогда аниматоры придумали хитрый трюк. Они нарисовали фон города в виде одного изображения, затем нарисовали движущиеся объекты, такие как мальчик Астро или машины в городе, на своих собственных прозрачных листах, известных как "cels", а затем сложили их вместе, чтобы камера думала, что все они - одно отдельное изображение. Это яркий пример наложения слоев.

![image](https://github.com/Maks1mio/doc-test/assets/44835662/e310c32f-6b3f-46f2-9fde-6607a49c1416)

В osu! слой работает точно так же. Мы можем назначить спрайты на определенные слои, и тогда в самом конце все они будут сложены вместе.
        
Есть четыре возможных слоя, которые мы можем использовать:
- **Background**
- **Fail**
- **Pass**
- **Foreground**

Единственное, о чем стоит упомянуть, это то, что слои fail и pass имеют свои собственные особые условия для появления видимости. Вы можете прочитать о них подробнее, щелкнув на глоссарии терминов, но в конце концов, проще просто принять менталитет, придерживаясь в первую очередь фонового и переднего плана.
Когда у вас есть несколько спрайтов на одном слое, тот, который создан позже (т.е. появляется позже в файле сценария), будет находиться поверх предыдущего(их) спрайта(ов). Это простой случай того, что называется z-порядком.
Звучит неплохо! Теперь, когда мы поняли, что такое слои, давайте заполним этот заполнитель слоем по нашему выбору. Давайте выберем Foreground.

<div class="code-container">
    <div class="svg-icon"><img src="~/staticV2/svg/laboratory/browser-code.svg" alt=""></div>
    <pre class="language-csharp"><code id="text-to-copy-2" class="language-csharp">Sprite, Foreground, <<span>origin>, "<<span>filepath>", <<span>x>, <<span>y></code></pre>
    <button class="copy-button" data-input-id="text-to-copy-2" type="button"><img
            src="~/staticV2/svg/laboratory/content-copy.svg" alt=""></button>
</div>
        
### Origin: Все начинается здесь

Прежде чем выбрать начальное местоположение, в котором будет находиться ваш спрайт, подумайте вот о чем: когда мы говорим osu! поместить спрайт в это пронумерованное место, где именно он находится? Для контекста, центр игрового поля находится по адресу (320,240). Если мы представляем себе изображение 1x1, или один пиксель, в точке (320,240), то это легко представить, поскольку пиксель является точным. Но рассмотрим спрайт размером 100x100. Какая часть изображения находится точно в точке (320,240)? Это верхняя левая часть изображения? Центр?

Это именно то, что подразумевает начало координат. Какую область изображения мы считаем точкой отсчета?

<note>
<div class="svg-icon"><img src="lib/svg/laboratory/todo.svg" alt=""></div><code
class="language-text">Добавьте рисунок, демонстрирующий девять точек начала изображения</code>
</note>
        
Существует девять возможных точек начала изображения:
- **TopLeft**
- **TopCentre**
- **TopRight**
- **CentreLeft**
- **Centre**
- **CentreRight**
- **BottomLeft**
- **BottomCentre**
- **BottomRight**

Наиболее вероятным выбором, который вы будете использовать, является Центр, поскольку такие вычисления, как перемещение и масштаб, обрабатываются намного, намного проще, чем другие настройки. Однако для особых ситуаций очень полезно иметь и другие точки отсчета. Для нашего примера давайте остановимся на Центре.
        
<div class="code-container">
    <div class="svg-icon"><img src="~/staticV2/svg/laboratory/browser-code.svg" alt=""></div>
    <pre class="language-csharp"><code id="text-to-copy-3" class="language-csharp">Sprite, Foreground, Centre, "<<span>filepath>", <<span>x>, <<span>y></code></pre>
    <button class="copy-button" data-input-id="text-to-copy-3" type="button"><img
            src="~/staticV2/svg/laboratory/content-copy.svg" alt=""></button>
</div>
        
### Filepath: Найди меня, сенпай!
        
Какое изображение вы хотите, чтобы отображался спрайт? Это относительно просто, но есть несколько предостережений, о которых следует помнить:
- Путь к файлу является относительным по отношению к файлу .OSB. Это означает, что папка набора карт будет начальным местом поиска файлов. Например, изображение с именем `"walrus.png"`, находящееся в той же папке, что и сценарий раскадровки, можно спокойно вызвать как `"walrus.png"`.
- При вызове изображений в подпапке mapset можно использовать прямую косую черту (`/`) вместо обратной косой черты. Если файл `"walrus.png"` хранится в папке `SB`, вы можете просто вызвать его через `"SB/walrus.png"` без каких-либо проблем. Хотя слеши в конечном итоге преобразуются в обратные слеши, это экономит гораздо больше времени на вводе `/`, чем `\`.

Это самые большие проблемы!

<note>
<div class="svg-icon"><img src="lib/svg/laboratory/todo.svg" alt=""></div><code
class="language-text">Кавычки вокруг пути к файлу также необязательны! Однако, если путь к вашему спрайту требует пробелов, то кавычки становятся обязательными. Имейте это в виду!</code>
</note>

В таком случае, мы можем просто продолжить наш пример с захватом прекрасного спрайта Хифуми.

<div class="code-container">
    <div class="svg-icon"><img src="~/staticV2/svg/laboratory/browser-code.svg" alt=""></div>
    <pre class="language-csharp"><code id="text-to-copy-4" class="language-csharp">Sprite, Foreground, Centre, "<<span>SB/hifumi.png>", <<span>x>, <<span>y></code></pre>
    <button class="copy-button" data-input-id="text-to-copy-4" type="button"><img
            src="~/staticV2/svg/laboratory/content-copy.svg" alt=""></button>
</div>

### Координаты: X отмечает точку!
        
Если вы не проспали ни одного урока алгебры, вы должны быть знакомы с понятием координатной плоскости, или двумерного графика, который отображает точки на горизонтальной и вертикальной осях, известных как X и Y. В математическом классе, однако, традиционная декартова система координат имеет точку начала координат, или (0,0), как некоторую центральную точку между четырьмя квадрантами, при этом возрастающие значения перемещаются вправо и вверх, а убывающие - влево и вниз. Однако в видеоиграх координаты работают по-другому, и система координат для osu! ничем не отличается.

В osu! для экрана 4:3 точка начала координат (0,0) находится в левом верхнем углу экрана или в левом верхнем углу игрового поля. В то время как X ведет себя точно так же: увеличивающиеся значения движутся вправо, а уменьшающиеся - влево, большее значение Y будет двигаться вниз, а меньшее значение Y - вверх. Границы экрана достигают 640x480 для экрана 4:3, что означает, что все, что выходит за пределы диапазона 0-640 и 0-480 для значений X и Y соответственно, считается вне экрана (хотя если спрайт достаточно большой, он может оказаться вне экрана лишь частично).

![Figma_SmgZWA5Xkb 2](https://github.com/Maks1mio/doc-test/assets/44835662/d1a3599c-558d-45a3-83c3-45ddccd944c9)
> Photoshop также использует эту систему координат при работе с пикселями на изображении, как показано на этом примере.

Когда osu! перешел к поддержке 16:9, или широкоэкранных раскадровок, общий размер экрана увеличился до 854x480. Однако для обеспечения обратной совместимости с существующими раскадровками исходная точка (0,0) осталась точно на том же месте, а вместо нее были открыты дополнительные пиксели слева и справа. Это расширило видимый экран от -107 до 747 для X.

Подводя итог, можно сказать, что вот важные значения, которые следует из этого извлечь:
- При увеличении значения X происходит перемещение вправо. Увеличивающиеся значения Y перемещаются вниз.
- Диапазон области просмотра для раскадровки 4:3 составляет 0-640 для X и 0-480 для Y.
- Диапазон области просмотра для раскадровки 16:9 составляет -107-747 для X и 0-480 для Y.
- Центр экрана находится в точке (320,240).

<note>
<div class="svg-icon"><img src="lib/svg/laboratory/todo.svg" alt=""></div><code
class="language-text">Являются ли эти числа произвольными!? Как вы узнали эти числа!? Рассмотрим центральную точку, 320. Половина размера экрана для 16:9 равна `854/2`, или 427. Вычтите или прибавьте это значение к 320, и вы получите -107 и 747 соответственно. Довольно круто, правда?</code>
</note>

Итак, со всеми этими разговорами о координатах, мы просто сделаем так, чтобы спрайт был отцентрирован. Достаточно просто, верно?

<div class="code-container">
    <div class="svg-icon"><img src="~/staticV2/svg/laboratory/browser-code.svg" alt=""></div>
    <pre class="language-csharp"><code id="text-to-copy-5" class="language-csharp">Sprite, Foreground, Centre, "<<span>SB/hifumi.png>", 320, 240</code></pre>
    <button class="copy-button" data-input-id="text-to-copy-5" type="button"><img
            src="~/staticV2/svg/laboratory/content-copy.svg" alt=""></button>
</div>

### Теперь все вместе...
<note>
<div class="svg-icon"><img src="lib/svg/laboratory/todo.svg" alt=""></div><code
class="language-text">Обобщите все разделы, упомянутые в "Объектах и слоях", до этой общей точки.</code>
</note>

### Анимации
<note>
<div class="svg-icon"><img src="lib/svg/laboratory/todo.svg" alt=""></div><code
class="language-text">Аналогично тому, как работают спрайты, напишите о том, как работают анимации, и приведите пример.</code>
</note>

### Резюмировать...
<note>
<div class="svg-icon"><img src="lib/svg/laboratory/todo.svg" alt=""></div><code
class="language-text">Являются ли эти числа произвольными!? Как вы узнали эти числа!? Рассмотрим центральную точку, 320. Половина размера экрана для 16:9 равна 854/2, или 427. Вычтите или прибавьте это значение к 320, и вы получите -107 и 747 соответственно. Довольно круто, правда?</code>
</note>

![image](https://github.com/Maks1mio/doc-test/assets/44835662/d40329e3-1127-443a-a9c2-e308cf43d8ab)
